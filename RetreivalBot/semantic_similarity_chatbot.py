# -*- coding: utf-8 -*-
"""semantic_similarity_chatbot.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KKx70s7XbtpiuNSNxreWrp3SdZZVbyDG
"""

from google.colab import drive
drive.mount('/content/gdrive')

!unrar e "/content/gdrive/My Drive/final_cleaned_data.rar" "/content"

!pip install spacy

!python -m spacy download en_core_web_lg

import random
import json
import numpy as np
import spacy
import nltk

nlp = spacy.load('en_core_web_lg')

def sentence_mean(nlp, s):
    if s == "":
        s = " "
    doc = nlp(s, disable=['tagger', 'parser'])
    return np.mean(np.array([w.vector for w in doc]), axis=0)
sentence_mean(nlp, "This... is a test.").shape

responses = {}
f = open('final_cleaned_data.json', 'r')
te = f.read() 
responses = json.loads(te)

sentences=[]
label=[]
for x in responses:
  sentences.append(x['message'])
  label.append(x['response'])

X_train_shape = (len(sentences),nlp.vocab.vectors_length)
X_train = np.zeros(X_train_shape)
# X_train

y_train_shape = (len(responses),nlp.vocab.vectors_length)
y_train = np.zeros(y_train_shape)
# y_train

for i,sentence in enumerate(sentences[:10000]):
   print(i)
   X_train[i,:] = nlp(sentence).vector

for i,response in enumerate(label[:10000]):
   print(i)
   y_train[i,:] = nlp(response).vector

from sklearn.model_selection import train_test_split
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.naive_bayes import MultinomialNB
from sklearn.metrics import accuracy_score
from sklearn.multiclass import OneVsRestClassifier
from nltk.corpus import stopwords
stop_words = set(stopwords.words('english'))
from sklearn.svm import LinearSVC
from sklearn.linear_model import LogisticRegression
from sklearn.pipeline import Pipeline

SVC_pipeline = Pipeline([
                ('tfidf', TfidfVectorizer(stop_words=stop_words)),
                ('clf', OneVsRestClassifier(LinearSVC(), n_jobs=1)),
            ])
for category in categories:
    print('... Processing {}'.format(category))
    # train the model using X_dtm & y
    SVC_pipeline.fit(X_train, train[category])
    # compute the testing accuracy
    prediction = SVC_pipeline.predict(X_test)
    print('Test accuracy is {}'.format(accuracy_score(test[category], prediction)))

import math
X_test_ten_thousands = X_train[:10000, :]
y_test_ten_thousands = y_train[:10000, :]

size = X_test_ten_thousands.shape[0]
per = math.floor((size * 70)/100)

X_train_s = X_test_ten_thousands[:per, :]
y_train_s = y_test_ten_thousands[:per, :]
X_test_s = X_test_ten_thousands[-(size-per):, :]
y_test_s = y_test_ten_thousands[-(size-per):, :]

print(X_train_s.shape)
print(y_train_s.shape)
print(X_test_s.shape)
print(y_test_s.shape)

# y_train_s_list = y_train_s.tolist()
# asd = np.array(y_train_s_list)
# np.reshape(asd, (7000, 1))
# print(asd.shape)
# print(len(y_train_s_list))
# print(len(y_train_s_list[0]))

from sklearn.svm import SVC

clf = SVC(C=1)
clf.fit(X_train_s, y_train_s)
print('Accuracy: {}'.format(clf.score(X_test_s, y_test_s)))

